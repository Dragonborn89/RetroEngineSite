<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>RetroEngine ‚Äî Dev Log 1: From First Light to First Frame</title>
<link rel="stylesheet" href="../style.css">
</head>
<body>

<header>
  <h1>Dev Log 1: From First Light to First Frame</h1>
  <nav>
    <a href="/">Home</a>
    <a href="/devlog/">Dev Log</a>
  </nav>
</header>

<main>
  <section>
    <h2> Getting Started</h2>
    <p>Haivng never setup a game engine or render pipeline, my first goal was setting up a self-contained Direct3D 12/Win 32 application in cpp. Its not much to look at, but this was the "birth" of my engine. A simple gpu-driven output of vertex and pixel shaders compiling üéâ! This would be the core everything else would build upon.</p>

    <img src="../assets/images/devlog01_01.jpg" alt="Engine Birth">

  </section>

  <section>
    <h2>Part I ‚Äî The Birth of the Beam</h2>
    <p>RetroEngine started as a Direct3D 12 prototype with one goal: to simulate a cathode-ray tube not as a post-process effect, but as a physically modeled display system.</p>

    <p>When you look closely at a real CRT screen, you don‚Äôt see pixels....you see phosphors. Tiny dots or stripes of red, green, and blue light that glow when struck by the electron beam. Different CRTs used different arrangements:<p>

    <ul>
      <li><strong>Shadow Mask:</strong> circular RGB triads like curved consumer televisions</li>
      <li><strong>Aperture Grille:</strong> vertical RGB stripes used in Trinitron and broadcast PVM monitors</li>
    </ul>

    <p>To begin building my physically-based CRT renderer, I needed to reproduce these layouts procedurally on the GPU. Every subpixel, every mask pattern, rendered in real time. The results can be seen in this image. The top is a reference diagram of real CRT masks. The bottom is the same pattern being generated by my engine. I taught the GPU how to draw those microscopic red, green, and blue structures that sit beneath every pixel:</p>

    <img src="../assets/images/devlog01_02.jpg" alt="Mask Patterns">


    <p>This is the foundation of RetroEngine...not a post-process filter, but a true simulation of how a CRT displays an image.The first milestone was creating the world a CRT actually lives in the phosphor mask.</p> 

    <p>Each pattern is generated procedurally in the shader (no textures, no lookup images). Every dot and stripe comes from math. This was where the renderer first felt alive: real-time phosphor geometry instead of static color blocks.</p>

    <video controls loop autoplay muted>
    <source src="../assets/videos/TestRendering01.mp4" type="video/mp4">
    </video>
    
  </section>

  <section>
    <h2>Part II ‚Äî Teaching Light to Move</h2>
    <p>Once the mask worked, I built the beam. A horizontal raster sweep now travels across the screen, lighting each phosphor as it passes. The shader models a Gaussian beam spread, scanline modulation, and a persistence buffer that fades over time.</p>

    <ul>
      <li>Gaussian + Lorentzian beam profile for soft edges without digital blur</li>
      <li>Scanline animation so the image ‚Äúdraws itself‚Äù frame by frame</li>
      <li>Afterglow persistence tuned per color channel</li>
    </ul>

    <p>For the first time, the renderer showed motion. Pixels glowed, trailed, and faded naturally. Running at 60 FPS, it was light behaving like matter.</p>
  </section>

  <section>
    <h2>Part III ‚Äî Persistence, Optics, and the Feeling of Glass</h2>
    <p>With the beam alive, I re-architected the renderer into a two-pass temporal pipeline to model how CRTs build light over time.</p>

    <p><strong>Pass A ‚Äî Persistence Builder:</strong> combines new beam emission with decayed light stored in HDR ping-pong buffers. This simulates phosphor decay and temporal blending to prevent digital flicker.</p>
    <p><strong>Pass B ‚Äî Composite & Output:</strong> applies optical shaping: vignette falloff, phosphor weighting, gamma shaping, and tone mapping. A subtle diffusion pass mimics how light scatters through the glass faceplate.</p>

    <p>After tuning the response:</p>
    <ul>
      <li>Dual-zone gamma (2.1 ‚Üí 1.85) deepened blacks while keeping midtones luminous</li>
      <li>Phosphor weighting balanced the warmth between green and red channels</li>
      <li>Low-frequency diffusion added a faint analog bloom</li>
    </ul>

    <p>The result was the first time RetroEngine felt physical ‚Äî deep contrast, smooth trails, and color that looked like energy rather than math.</p>
  </section>

  <section>
    <h2>Part IV ‚Äî The Mystery of the Muted Greens</h2>
    <p>During a refactor, I finally found the bug that made every scene look flat. Textures were loaded as sRGB but sampled as linear UNORM, so the shader was reading gamma-encoded values. The CRT pass then applied its own shaping, and the GPU encoded again ‚Äî effectively double darkening the image.</p>

    <p>Fixing it meant rebuilding the color pipeline:</p>
    <ul>
      <li>Textures flagged as sRGB so the GPU linearizes automatically</li>
      <li>CRT pass operates entirely in linear HDR (R16G16B16A16_FLOAT)</li>
      <li>Swapchain performs a single sRGB encode at output</li>
    </ul>

    <p>Once fixed, the change was immediate. Greens came alive. Blues regained depth. The glow math behaved like real energy. The renderer finally felt unified from input to glass.</p>
  </section>

  <section>
    <h2>Part V ‚Äî The Cube Lives</h2>
    <p>With the CRT system stable, I gave it something real to draw: a simple 3D cube. I added a camera, transform matrices, and a mesh loader. That cube became the first object rendered through the full beam and persistence pipeline.</p>

    <ul>
      <li>A geometry pass renders to an HDR buffer</li>
      <li>The buffer feeds into the CRT system as its signal</li>
      <li>The beam simulation, phosphor decay, and optical bloom process it in real time</li>
    </ul>

    <p>Watching that cube flicker through the simulated raster proved it. RetroEngine isn‚Äôt a filter. It‚Äôs a viewport model ‚Äî a virtual CRT capable of showing real worlds.</p>

    <!-- Optional short clip -->
    <!--
    <video controls autoplay muted loop style="max-width:90%;display:block;margin:2em auto;border-radius:8px;box-shadow:0 0 12px #00fff2;">
      <source src="../assets/videos/log1_demo.mp4" type="video/mp4">
    </video>
    -->
  </section>

  <section class="summary">
    <h2>Closing Thoughts</h2>
    <p>This first stage was about one thing: light. Understanding it, shaping it, and making it behave the way it did on glass. The CRT system is alive now. Next up is giving that light a world to illuminate.</p>
  </section>

</main>

<footer>
  <p>¬© 2025 RetroEngine ‚Äî Built by Alex Rybak</p>
</footer>

</body>
</html>
